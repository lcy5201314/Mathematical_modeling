%This is an implementation of the Gaussian BP algorithm% Written by Danny Bickson%See: http://books.nips.cc/papers/files/nips18/NIPS2005_0210.pdf%Equations 7,8,9%Input: A - information matrix mxm, (assumed to be symmetric) and%diagonally dominant.%B - shift vector 1xm%C - constraint that h <= C, for all i=1:m%Output: The solution for the inference problem%        vector h of size 1xm s.t. h = max(1/2h'Ah +h'b)%        J - vector of the values Pii (the diagonal of the matrix A^-1)function [h,J,r,C] = GBP(A,b,maxround,epsilon)%format long e;%assert(length(A) == length(b));m=length(A);%messagesMh=zeros(m,m);MJ=zeros(m,m);%return valuesh=zeros(1,m);J=zeros(1,m);%conv = false;C=zeros(maxround,m);% algorithm roundsfor r=1:maxround    disp(['starting GBP round ', num2str(r)]);     old_MJ = MJ;    old_Mh = Mh;    MJ = zeros(m,m);    Mh = zeros(m,m);	% for each node   for i=1:m		% sum up all mean and percision values got from neighbors		h(i) = b(i) + sum(old_Mh(:,i));  %(7)        		%variance can not be zero (must be a diagonally dominant matrix)!        assert(A(i,i) ~= 0);        J(i) = A(i,i) + sum(old_MJ(:,i));		% send message to all neighbors	for j=1:m			if (i ~= j && A(i,j) ~= 0)				h_j = h(i) - old_Mh(j,i);				J_j = J(i) - old_MJ(j,i);				disp([num2str(i), '.', num2str(j), 'h_i', num2str(h_j), 'j_j', num2str(J_j)]); %               assert(A(i,j) == A(j,i));			    assert(J_j ~= 0);                Mh(i,j) = (-A(j,i) / J_j)* h_j; %(8)				MJ(i,j) = (-A(j,i) / J_j) * A(i,j);            end    end		%disp(['h is : ', num2str(h-b)]);		%disp(['J is : ', num2str(J)]);			                %h   end    max_diff  = epsilon;       Mh    MJ	%sum(Mh)	%sum(Mh')    for i=1:m        h(i) = b(i) + sum(Mh(:,i));  %(9)        J(i) = A(i,i) + sum(MJ(:,i));    end    J=1./J;    h=h.*J;    C(r,:)=h;    %diffMj = MJ - old_MJ;    %if (max(abs(diffMj)) < max_diff)   if (r > 2 && ((norm(C(r,:) - C(r-1,:))/norm(C(r,:))) < epsilon))        disp(['GBP (MJ) Converged afeter ', num2str(r), ' rounds ']);         conv = true;		break;   endendif (conv == false)	disp(['GBP (MJ) Did not converge in ', num2str(r), ' rounds ']);end%assert(J ~= 0);%J = 1./J;%h=h.*J;disp(['GBP result h is: ', num2str(h)]);disp(['GBP result J is: ', num2str(J)]);